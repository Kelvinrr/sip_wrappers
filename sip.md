# Wrapping

Wrapping types in Sip involves a `.sip` file which strongly mimics a standard C++ header file with some extra markup to define things like modules and type conversions. Anything included in the `.sip` files is what is exposed in python.

## Required extent of coverage

When creating your `.sip` files, you only need to include the things that you plan to expose in Python or is being used by a function being exposed in Python. That is, types used as a parameter or return type of a function must be also exposed via Sip and any custom type conversion code must be supplied (e.g. a `%MappedType` directive).

If there is a function that uses an unexposed type in its body, you do not need to expose it to Python.

## Classes & Structs
**SomeClass.h**
~~~~C++
// Define the interface to the library.
class SomeClass {
private:
    const char *the_word;

public:
    SomeClass(const char *w);

    char *do_something() const;
};
~~~~

**SomeClass.sip**
~~~~C++
// Define the SIP wrapper to the word library.

%Module (name=SomeModuleName)

class SomeClass {

%TypeHeaderCode
#include <SomeClass.h>
%End

public:
    SomeClass(const char *w);

    char *do_something() const;
};
~~~~

As you can see, the sip file mimics the Makefile almost exactly.
The differences:

* The `%Module` directive, this is used to define the `.sip` file as the definition of a Python module.
* The `%TypeHeaderCode` directive, anything in this block contains any necessary headers for the class. At minimum it should always contain the `#include` for the class being exposed.

> **NOTE ON C STRUCTS** Structs have the exact same syntax, except, obviously, with `struct` in place of `class`, since classes and structs are practically synonymous in C++. Although, if you are using pure C code, then change the module language to C with `%Module(name=SomeModuleName, language="C")`.

## Method & Type Code
All types for a method signature and return type must be defined. That is, if there is a custom type used used in either the parameters or return type, and it is not defined in a `.sip` file, Sip will return errors. Types that are wrapped in another object, like containers and smart pointers, require custom type code code even if it is wrapping a common type, such as primitive types (double, int, char, etc.).

For example, types like `QSharedPointer<CustomType>`, `std::vecor<CustomType>`, `std::vector<double>` all require custom code to convert the C++ type to a Python type. In the `std::vector` case, you must define how the `std::vector`'s elements get inserted into a Python container (Python list, Numpy array, etc).

Types that require custom definitions or type conversion:
* Any custom classes
* Any containers (e.g. `QList<SomeType>`)
* Any Wrapped Classes (e.g. `SmartPointer<SomeType>`)
* Any pointers (e.g. C arrays)

Types that do not require custom definitions:
* Most standard C/C++ types
* Most QT types
* Primitive types

Types that require conversions will need %MethodCode or %MappedType directives defined for the type or individual function.

### Useful Sip functions and implicit objects

**type \*sipCpp** -- This is an implicit object inside conversion code that stores the C++ version of the object being mapped/wrapped. In `%MethodCode`, it is a `this` pointer for the method's class. In `%MappedType`, it is the object being mapped.

**type \*sipPy** -- Python equivalent to sipCpp.

**bool sipSelfWasArg** It is set if self was explicitly passed as the first argument of the method. That is, sipSelfWasArg is set if and only if, on the Python side, the function was called as `class.func(self, ...)` rather than `class.func(...)`.

**int sipRes** sipRes is the implicit object storing an error code after a sip function call. Should be zero when there is no error, -1 otherwise.

**type \*a0, a1, a2 ... an** -- When working with `%MethodCode` directives, sip has implicit objects `a0`, `a1`, `a2` ... `an` which are short for argument 1, argument 2, argument 3 .. argument n. These store the arguments in the order that they defined in the function signature. Use them when you need access to the arguments in order to convert them within method code.

[**PyObject \*sipConvertFromType(void \*cpp, const sipTypeDef \*td, PyObject \*transferObj)**](http://pyqt.sourceforge.net/Docs/sip4/c_api.html#c.sipConvertFromType)  
Used to convert a C/C++ Type to a PyObject. If the type has a Sip definition, then there exists a sipTypeDef for it. The autogenerated sipTypeDef begins with sipType and then is the type as an underscore delimited top-down list of the enclosing scopes ending with the object type. (e.g. NameSpace1::NameSpace2::OuterClass::InnerClass will become sipType_Namespace1_Namespace2_OuterClass_InnerClass). The converted object is stored in the last parameter.

[**void \*sipConvertToType(PyObject \*obj, const sipTypeDef \*td, PyObject \*transferObj, int flags, int \*state, int \*iserr)**](http://pyqt.sourceforge.net/Docs/sip4/c_api.html#c.sipConvertToType)  
Used to convert a PyObject back to the appropriate C++ Object. Use is very similar to sipConvertFromType.

more can be found [here](http://pyqt.sourceforge.net/Docs/sip4/directives.html).

### %MethodCode Directives
When a particular function needs special code in order to convert function args, then the `%MethodCode` directive is necessary. The directive must immediately follow the appropriate method definition.

~~~~C++
// someFunction() normally accepts an int* C array if size two, so we need to write custom MethodCode to convert the C array to a PyTuple
// C++ function: int someFunction(int*) {...}
// As the python call accepts a PyTuple, we have changed the arg type
...
virtual int someFunction(SIP_PYTUPLE);
%MethodCode
    int *iarr = malloc(2*sizeof(int));

    if (PyArg_ParseTuple(a0, "ii", &iarr[0], &iarr[1]))
    {
        // ParseTuple didn't return an error, so call the function
        // with the new PyTuple
        Py_BEGIN_ALLOW_THREADS

        sipRes = sipSelfWasArg ? sipCpp->Klass::foo(iarr)
                               : sipCpp->foo(iarr);
        Py_END_ALLOW_THREADS
    }
    else
    {
        // PyArg_ParseTuple() will have raised the exception.
        sipIsErr = 1;
    }
%End
...
~~~~

#### Additional Annotation used in conjunction with %MethodCode
A function can be decorated with annotations to specify specify how the function is to be processed.

Here are some common annotations generally needed with some examples, more can be found [here](http://pyqt.sourceforge.net/Docs/sip4/annotations.html).

`/In/` -- Needed for any C arrays passed into a function definition. C arrays marked with `\In\` will automatically have each member dereferenced when accessed, otherwise you will simply get an address in return. This annotation is implied for `char*` and `unsigned char*` but must be explicitly defined for any other C array.

`/KeywordArgs=<option>/` -- Put at the end of a function definition in order to define all function arguments as keyword arguments when called on the python side. Options are: `"None" meaning that keyword arguments are not supported, "All" meaning that all named arguments can be passed as keyword arguments, or "Optional" meaning that all named optional arguments (i.e. those with a default value) can be passed as keyword arguments. EX: `int func(int foo, int bar = 0) /KeywordArgs="Optional"/` will make foo a position argument and bar a keyword argument.





### %MappedType Directives
Sometimes it doesn't make sense to expose containers like `QList` or `std::vector` to python. Furthermore, there are types that cannot be exposed directly, like a C array. In this case it makes more sense to map between C/C++ types and Python types (e.g. `std::vector` to `PyList` or C array to Numpy array).

`%MappedType` Directives allow you to define this mapping while allowing re-usability. Under `%MappedType`, you need two other directives:
* `%ConvertFromTypeCode`: Code mapping the C/C++ type to Python
* `%ConvertToTypeCode`: Code mapping the Python type to C/C++

These two directives are essentially functions that are called every time you make a call to anything using the mapped type.

~~~~C++
%MappedType SomeType
{
  %TypeHeaderCode
    // list of necessary C/C++ #includes
  %End

  %ConvertFromTypeCode
    // write code to extract the Python type from a C/C++ type
  %End

  %ConvertToTypeCode
    // write code to extract the C/C++ type from a Python type
  %End
};
~~~~

### Examples of custom type conversion code.
-----
#### PyLists
Mapping types to PyLists depends on the Python C API in order to create and modify PyLists. Python C API Documentation for PyLists can be found [here](https://docs.python.org/3.6/c-api/list.html).

Converting to a PyList:
* Create a new PyList that matches the size of your C/C++ container
* Iterate over each element converting C/C++ elements to PyObjects
* Insert the PyObjects to the new PyList
* Return the PyList pointer

Converting from a PyList to a C/C++ container is the same, but in reverse (duh).

~~~~C++
// Example of converting from a QList to PyList
%MappedType QList<SomeType>
{
  %TypeHeaderCode
  #include "SomeType.h"
  %End

  %ConvertFromTypeCode
    // sipCpp is an implicit object, basically a pointer the
    // instance currently being mapped.
    size_t size = sipCpp->size();
    PyObject *l = PyList_New(size);

    // iterate over all elements and copy them into the PyList
    for (size_t i = 0; i < size; ++i) {
      // Create a pointer to an element
      SomeType* cppStats = new SomeType(sipCpp->at(i));
      // convert from a C/C++ type to Python
      PyObject *pyObj = sipConvertFromType((void*)(cppStats), sipType_SomeType, NULL);
      // put it into the PyList object
      PyList_SetItem(l, i, pyObj);
    }

    // return the PyList
    return l;
  %End

  %ConvertToTypeCode
    Py_ssize_t size = PyList_Size(sipPy);
    QList<SomeType> *cppList = new QList<SomeType>();
    int sipErr = 0;
    for(int i = 0; i < size; i++) {
      // get the element from the list
      PyObject *pyStat = PyList_GET_ITEM(sipPy, i);
      // Convert to a C/C++ type from Python
      SomeType *cppType = (SomeType*)sipConvertToType(pyStat, sipType_SomeType, NULL, SIP_NOT_NONE, NULL, &sipErr);
      // add it to the C/C++ container
      cppStatList->append(*stats);
    }
    *sipCppPtr = cppStatList;
    return sipGetState(sipTransferObj);
  %End
};
~~~~

----

#### Numpy Arrays

If you have an array-like structure and you want to take advantage of Numpy in your Python code, converting a C/C++ structure to a Numpy array will make most sense.  

~~~~C++
...
// method with an argument being converted to a Numpy array
void Allocate(int width, int height, bool withHost, float *devMem /In/ = NULL, SIP_PYOBJECT *hostMem /In/ = NULL) /KeywordArgs="All"/;
%MethodCode
    // import the Numpy C Api, always call this when working with Numpy arrays
    import_array();
    //Interpret arg5 as a numpy array
    PyObject *hostmem = PyArray_FROM_OTF(a4, NPY_FLOAT32, NPY_ARRAY_C_CONTIGUOUS | NPY_ARRAY_ALIGNED | NPY_ARRAY_ENSUREARRAY);

    //Check that the above worked and did not return a NULL pointer
    if(hostmem == NULL){
      Py_XDECREF(hostmem);
    }

    //Get a pointer to the data as C-types
    float *x = (float*)PyArray_DATA(hostmem);

    //Call the function
    sipCpp->Allocate(a0, a1, a2, NULL, x);
%End

...
~~~~

Also See : [Numpy Array Api](https://docs.scipy.org/doc/numpy-1.10.0/reference/c-api.array.html#creating-arrays)

----

#### QObjects

Most QObjects do not need any conversions as Sip comes with a collection of `.sip` files with definitions for QT objects. The exceptions are wrapper classes & containers (e.g. QSharedPointers, QMaps, etc.).

The idea is to simply extract the contents and then stuff them into the appropriate structure.

~~~~C++
// convert SomeClass wrapped in a QSharedPointer
%MappedType QSharedPointer<SomeNamespace::SomeClass>
{
  %TypeHeaderCode
  #include "SomeClass.h"
  #include <QSharedPointer>
  %End

  // from C/C++ to Python
  %ConvertFromTypeCode
    PyObject *pySettings = sipConvertFromType(sipCpp, sipType__SomeNamespace_SomeClass, NULL);
    return pySettings;
  %End

  // from Python to C/C++
  %ConvertToTypeCode
    int sipErr = 0;
    QSharedPointer<SomeNamespace::SomeClass> *someTypeQSP;
    SomeNamespace::SomeClass *cppType = (SomeNamespace::SomeClass*)sipConvertToType(sipPy,
      sipType__SomeNamespace_SomeClass, NULL, SIP_NOT_NONE, NULL, &sipErr);

    someTypeQSP->reset(cppType);

    *sipCppPtr = qspControlNet;
    return sipGetState(sipTransferObj);
  %End
};
~~~~


----


#### Pointers

# Building

## via a configure.py script
One way to build is to write a configuration Python script that generates the Sip `.cpp` files and the necessary MakeFile to build the Python bindings.

~~~~Shell
python configure.py
make install
~~~~

configure.py should:
* Run the Sip application with the `.sip` files as input along with the proper QT flags.
* Use the the Python Sip library (`sipconfig`) to setup the correct Make flags and generate the MakeFile.
* Make any necessary tweaks to the makefile

#### Run the sip application
~~~~Python
from PyQt5.QtCore import PYQT_CONFIGURATION

os.system(" ".join([sip_bin, "-c", ".", "-b", build_file, "-I", pyqt_sip_dir,
    PYQT_CONFIGURATION["sip_flags"], sip_file_list]))
~~~~
First, you need to get the QT sip flags which are contextual based on how your version of QT was built. PyQt offers a convenient dictionary called `PYQT_CONFIGURATION` with this information. We only care about the key `"sip_flags"`.

Given the build file, `.sip` files and the typical Sip flags, you can run `sip` with a call to `os.system` to generate the `.cpp` files.

#### Using sipconfig to set Make flags
~~~~Python
import sipconfig

makefile = ModuleMakefile(configuration=sipconfig.Configuration(), build_file=build_file, installs=installs)
makefile.extra_cxxflags = extra_cxxflags_list
makefile.extra_lflags = extra_lib_dirs_list
...
makefile.generate()
~~~~

Sip comes with the `sipconfig` module which contains the classes which can be used to generate MakeFiles. For the sake on generating a new Python module, we are interested in the `sipconfig.ModuleMakefile` class. The class needs:

* The `sipconfig.Configuration()` object containing Sip configuration information
* The build file (i.e. the `.sbf` file) location
* The installs list
* Extra MakeFile flags stored as lists, these include:
  * `extra_cxxflags`
  * `extra_cflags`
  * `extra_ldflags`
  * `extra_defines`
  * `extra_include_dirs`
  * `extra_lflags`
  * `extra_lib_dirs`
  * `extra_libs`
  * `extra_source_dirs`

>**NOTE** The extra_XXXXX attributes will automatically add the appropriate flags in front of elements in the accepted list (e.g. extra_includes will add `-I` to everything in the list, so `makefile.extra_include_dirs = ['boost/']` will generate the string `HEADERS = -I/boost`, extra_libs will add `-l`, etc.) therefore, you should not include those flags, otherwise you will encounter errors when invoking `make`.

Finally, make a call to `ModuleMakefile.generate()` to generate the Makefile.

#### Tweaking the MakeFile
There are edge cases where you may need to add content to the Makefile that the auto Makefile generation doesn't support. For example, if you need to add libs to the auto generated Makefile from another Makefile. Adding it as part of `extra_libs` will add `-l` to the variables causing errors when invoking `make`.

Unfortunately, the only solution to open the makefile for writing and make the modifications yourself within the configuration file.  

## via CMake
